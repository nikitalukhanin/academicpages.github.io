---
title: 'Inverse Kinematics'
date: 2020-07-18
permalink: /projects/inversekinematics/
tags:
  - robot arm
  - 3d printed
  - arduino
code-block-font-size: \tiny
---

Inverse Kinematic controls designed around an open-source 3d printable robotic arm for implementation in an Arduino control setting.

Robot Arm Inverse Kinematics
======

Controlling individual joints on a robot arm to complete a task is an awkward task to do. Looking at commercial robots, most if not all robotics companies such as Fanuc, Boston Dynamics, and Kuka all implement control systems alongside their robots. This software makes the job of programming the robots a cakewalk compared to what it would have otherwise been. This is the premise of my project: implementing my own inverse kinematic algorithm to make controlling a robot arm simple.
<br/><img src='/images/lhouse.jpg' style='width:300px;'>

I chose to print daGHIZmo's EEZYbotARM on my Prusa Mini due to its popularity, control simplicity, and small size making it easy to use.

<br/><img src='/images/lhouse.jpg' style='width:300px;'>

The first step is to determine the rotators position along the XY plane. By forming a triangle across the surface, the angle for the rotator can be determined:
```c++=34
float rotatorAngle = atan(posX / posY) / (6.28318530718) * 360;
	 rotator.write(-rotatorAngle + 90);
```

This step simplifies the 3D problem into a 2D problem that we can then solve with trigonometry. I know the location of the base and where the hand should be (the desired coordinate) as well as the lengths of each side. Thus to determine the angles of the shoulder and elbow, I form a triangle whose vertices are the shoulder joint, elbow joint, hand and we solve:
```c++=37
// Creation of general units such as directional distances as well as angles
  float dist = sqrt(pow(posX, 2) + pow(posZ, 2) + pow(posY, 2));
  float distXY = sqrt(pow(posX, 2) + pow(posY, 2));
  float orthRad = atan(distXY / posZ);
  float orthDist = sqrt(pow(8, 2) - pow(dist / 2, 2));

  // Creates vertical and horizontal components of the shoulder and outputs as an angle
  float shoulderXY = distXY / 2 - orthDist * cos(orthRad);
  float shoulderZ = posZ / 2 + orthDist * sin(orthRad);
  float shoulderAngle = (atan(shoulderXY / shoulderZ) / 6.28318530718) * 360;
  shoulder.write(shoulderAngle + 50);

  // Creates vertical and horizontal components of the elbow and outputs as an angle
  float elbowDistXY = distXY - shoulderXY;
  float elbowDistZ = posZ - shoulderZ;
  float elbowAngle = atan(elbowDistZ / elbowDistXY) / (6.28318530718) * 360;
  elbow.write(elbowAngle + 90);
```
